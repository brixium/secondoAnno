Architettura dei calcolatori e sistemi operativi 
Martedì 17 settembre 2019

Prof. Donatella Sciuto (vice rettore) + Luca Stornaiuolo
RIceve su appuntamento
Prova in itinere ma funziona un po'diversamente
Prima parte del corso: architettura dei calcolatori
	Testo: David A. Patterson, John L.Hennessy; Struttura e progetto dei calcolatori edito Zanichelli; ->architettura dei calcolatori
	Testo 2ndo sem: dispense online su BeeP.  ->sistemi operativi e programmazione concorrente (Linux)
TDE disponibili su BeeP. 
Lezione misto tra slide e lavagna

Modalità d'esame: 2 prove separate anche agli appelli: 1 sull'architettura dei calcolatori, l'altra sui sistemi operativi.
Ogni prova assegna 16 punti, la si passa con almeno 7 punti, 18 su tutte e due.
È possibile sostenere le prove in appelli differenti.
Sconsigliato fare le prove insieme.
All'esame ti danno tutto quello che dovresti impararti a memoria, tipo Bolchini.

Partiamo col singolo processore
Programmazione multithread, non vedremo problemi di design: sicurezza, surriscaldamento, efficienza energetica.
Architettura del calcolatore è coordinamento di molti livelli di astrazione.

Linguaggio di alto livello > Instruction Set Architecture > codice binario
ISA è relativo ad una architettura di CPU. Ed è quella che divide il sw dall'hw.
Il SO nasconde le funzioni hardware al software fornendo interfacce.
Firmware è la più vicina all'hardware
Transistor > circuiti > porte logiche >|| microarchitettura > ISA (architettura) > Sistema runtime(VM, OS, FS) ||> programma/linguaggio.
SO gestisce: processi, memoria e File System.

Livelli di astrazione:
C > assembly (MIPS) > linguaggio macchina (MIPS) > descrizione architettura hw a blocchi > descrizione circuito logico (diagrammi schematici dei circuiti).

Temi:
1) ISA (cpaitolo 2 fino a 2.14 e appendice A escluse le parti in Java)
	-linguaggio assembly (MIPS)
	-tradurre da C in assembly
	-tradurre dall'assembly al codice macchina
2)componenti hw:
	-porte logiche
	-circuiti combinatori
	-elemeti di memoria
3)il processore
4)la gerarchia di memoria (cap.5 fino a 5.4)
5)il bus: introduzione

il capitolo 5.7 verrà trattato nella seconda parte del corso con i sistemi operativi.

Legge di Moore: ogni 2 anni / 18 mesi, ci sono 2X transistor. Oggi il trend si è rallentato un po'per problemi di architettura.

Principi fondamentali:
	il programma viene mandato in esecuzione, lo si manda in memoria e si invia la prima istruzione al processore
	dopodiché esecuzione sequenziale
Architettura di Von Neumann
	|-CPU con ALU, Registri+PC, controllo
	|-Memoria
	|-Interfaccia di I/0 <-->memoria di massa
	|-I/0 <--> tastiera/video
	^ bus di dati, indirizzi e controllo (protocollo).

Struttura del data path:
Programma in c: 
int a, b, c;
c = a + b;
^ 1 istruzione in c che diventano 4 istruzione assmbly:
	.carica a da memoria a registro
	.carica b da mem a reg
	.esegui somma dei 2 registri
	.spostamento dell'output ALU da registro a memoria.
in altre parole: Caricare c, a e b nei registri in memoria, poi si portano nei registri di ingresso dell'ALU e si portano ai bus di ingresso all'ALU.

Categorie di istruzioni:
	Registro-memoria
		-trasferimento dati tra registri CPU e la memoria centrale
		-l'unità di informazione trasferita è la parola (word)
	Registro-registro
		-utilizzano il contenuto dei registri per svolgere operazioni (tramite ALU) e memorizzano il risultato in un ciclo di data path.
		-ciclo di data path

Esecuzione delle istruzioni
	Ciclo Fetch-Decode-Execute
			1)prendi l'istruzione corrente dalla memoria e la metti nel registro istruzioni (IR)
			2)incrementa il PC in modo da contenere l'indirizzo dell'istruzione successiva
			3)determina il tipo dell'istruzione corrente (decodifica)
			4)se l'istruzione usa una parola in memoria, determina dove si trova
			5)carica la parola in un registro CPU se necessario
			6)Esegui l'istruzione
			7)torna al punto 1 e esegue l'istruzione successiva

L'istruzione è divisa in campi:
	campo codice operativo indica il tipo di operazione
	gli altri campi indicano gli indirizzi degli operandi oppure gli operandi stessi. Gli indirizzi possono riferirsi ad indirizzi di memoria o reg della CPU.
modalità di indirizzamento

Noi usiamo MIPS a 32 bit 
2 tipi di processori: 
	quelli che vogliono entrambi i dati su cui operare provenienti dalla memoria debbano essere caricati nei registri -> architetture LOAD STORE (quelle più moderne)

Il normale flusso di esecuzione di un programma può essere interrotto da un segnale di INTERRUPT per richiesta di intervento che un dispositivo I/O manda al processore.
Con esso i dispositivi di I/O possono segnalare cose al processore.

Un po'di storia: RISC e CISC
I primi computer avevano delle ISA semplici, via via rese sempre più complesse.
Negli anni '70 andavano molto i processori microprogrammati CISC, realizzati con l'idea di fornire istruzioni molto complesse che rispecchiassero i costrutti dei liguaggi ad alto livello. Microprogramma per realizzare istruzioni complesse. Falsa credenza che avessero delle implementazioni HW più efficienti.
Negli anni '80 c'è stato l'avvento dei RISC, di cui il MIPS fa parte. Istruzioni semplici, tempi di esecuzioni molto brevi.
Vantaggi del RISC: spazio risparmiato per implementazione istruzioni extra viene impiegato per memorie cache per velocizzare istruzioni; uniformità delle istruzioni per velocizzarne la decodifica; uniformità e prevedibilità dei tempi di esecuzione delle istruzioni permette di eseguire più operazioni in parallelo.
Intel creò un nucleo RISC ma aggiunge in hardware un assembler che traduce dall'assembly CISC all'allora nuovo RISC.

Noi utilizziamo il MIPS (R2000/R3000 RISC)
Usando l'interprete MARS o SPIM possiamo farlo.

Registro da 32 bit, possiamo indirizzare fino a 2^32 B di memoria (4GB).
La memoria è indirizzabile a byte con parole da 4 byte.
Gli ultimi 2 bit alla fine della parola servono a poco.

Bus dati
Bus indirizzi
Bus di controllo

Esempio: operazione di lettura dalla memoria
	il bus indirizzi viene riempito con l'indirizzo della parola desiderata e inviato alla memoria
	quando la memoria ha finito di leggere la parola richiesta, il dato viene trasferito al bus dati e la CPU può prelevarlo
	nella struttura a bus singolo tutte le unità del calcolatore sono connesse al bus.

Ripasso numeri binari


CAPITOLO 2

Introduzione Assembler

Per il C la compilazione avviene in 3 fasi: compilazione (che crea file oggetto .obj), linking (con anche programmi di libreria), caricamento ed esecuzione.
Il linguaggio assembler è più primitivo: no controllo di flusso, solo GOTO. Linguaggio molto restrittivo (es. istruzioni aritmetiche hanno numero piccolo e fisso di operandi). Due processori con lo stesso linguaggio macchina hanno la stessa architettura anche con implementazioni hw diverse.
Incrementare il Program Counter lo fa avanzare di 4 (essendo a 32 bit).
I primi 6 bit indicano l'operazione da eseguire. I primi 6 bit a 0 indicano un'operazione aritmetica, descritta dagli ultimi 6 bit.
Utilizzando un traduttore inverso o disassemblatore posso tradurre dal linguaggio macchina in assembly.
I comandi con dei punti danno delle direttive all'assembler: 
	.text e .data indicano che le linee successive contengono istruzioni o dati
	.align n: indica l'allinamento su 2^n
	.global main: l'etichetta main è globale, ossia visibile dal codice in altri file
	.asciiz: area di memoria che memorizza una stringa terminata da 0
sw è store word
sd è store double
lw è load word
mul moltiplicazione
ble branch less or equal (salta se minore o uguale (sottointeso a 0))

Categoria di istruzioni:
	aritmetico logiche
	trasferimento memoria
	di controllo (flusso exec)
Esse hanno una codifica, un formato (nel MIPS ce ne sono 3, ciascuna per ciascuna categoria).
Le istruzioni del MIPS hanno solo 2 operandi e 1 risultato.
Sia operandi che risultato devono essere contenuti nel registro.
Non confondere variabili e registri. Variabili infinite, 32 registri codificati in bit, da 0 a 31. Sono numerati col $ davanti ($0, $1, ..., $31). Alcuni hanno dei nomi simbolici. $0 ha dentro 0, $1 è riservato (chiamato anche $at). I valori di ritorno sono salvati in $2 e $3, poi c'è il resto.


Mercoledì 18 settembre 2019

26enne Luca Stornaiuolo luca.stornaiuolo@polimi.it
Iscritto nel 2012, laurea triennale nel 2015. Si è iscritto ad una laurea magistrale ed era spaventato dall'ostacolo dell'inglese. Nel 2016 entra nel NECST (laboratorio basato sull'hardware). Hackaton. may 2017 NGC @San Francisco. 
Forze oscure: prof.Santambrogio, collaborazione IBM<->Polimi a Cambridge, Massachussets. Laurea magistrale a ottobre 2017.
Da nov.2017 dottorato: dura 3 anni e fai ricerca sull'ing.informatica.

Assembler MIPS
Libro di testo: Patterson Hennessy capitolo 2, usiamo MARS
In MIPS ci sono operandi e registri.
variabili =/= registri
I 3 tipi di istruzioni MIPS:
	(R)egister: operazioni aritmetico-logiche. Diverse istruzioni.
		istruzione destinazione, src1, src2
		add: serve per sommare il contenuto di due registri
			es: add rd, rs, rt //andrà a sommare rs e rt e metterà il risultato in rd.
		sub: sottrae
	(I)mmediate

	(J)ump

Esempio R: a = (b+c) - (d-f) + g.
$s1 è b, $s2 è c

trasferimenti con la memoria: istruzioni lw e sw

Load Word (LW)
lw carica il contenuto dalla memoria
es. lw $s1, 48($s2)
                ^base register che contiene il valore del base address
			 ^offset
		^dove va a salvare

SW è analogo a lw ma è store
es. sw $s1, 96($s2)
				^a questa locazione + offset viene assegnato il valore dentro s1

li e la, load immediate e load address
li $v0, 4 (carica la costante 4 in v0)
la $a0, num1 (carica l'indirizzo num1 in a0)

Differenza tra la e lw

Big endian e little endian. MIPS è in grado di operare con entrambi i metodi
Big endian è avere i byte enumerati da sinistra a destra, little endian è da destra a sinistra.

varianti dell'addizione: addi(immediata), addu (senza segno) e addiu (immediata e senza segno).

Esistono registri referenziabili e non referenziabili 
Moltiplicazione: mult rs rt, senza segno: multu rs rt
il registro del risultato della moltiplicazione è implicito. È messo in due registri speciali: hi e lo.
Il risultato della moltiplicazione si preleva dal registro hi e da lo tramite due operazioni: mfhi e mflo

Divisione: div e divu. Simile a prima

Istruzioni logiche
	and			and rd, rs1, rs2
	or			or rd, rs1, rs2
	nor			nor rd, rs1, rs2
	lshift		sll rd, rs, #bit
	rshift		srl rd, rs, #bit
esistono anche andi e ori ovvero and/or bit a bit tra un operando e una costante

Se devo fare una moltiplicazione per un multiplo di due uso lo shift a sinistra in un solo ciclo di clock anziché 4 o 6.
I bit inseriti durante lo shift sono settati a 0.

Array
L'indirizzo dell'iesimo elemento di un array si troverà nell'elemento br + (4*i) //4 sono il numero di byte in una word

(J)ump: istruzioni di salto.
Normalmente l'esecuzione è sequenziale.
Il Program Counter (PC) indica dove si trova la prossima istruzione da eseguire, quindi normalmente PC=PC+4.

Si può modificare il flusso di istruzioni con:
	-salto condizionato (branch) -> al verificarsi di una condizione viene eseguito. 
		Se la reg1==reg2: beq reg1, reg2, ind_salto
	-salto incondizionato (jump) -> viene sempre eseguito
		jump: j addr
		jump and link: jal
		jump register: jr reg

Etichette (labels)
vengono usate per essere ritrovate facilmente, l'assembler le sostitiusce in fase di compilazione

Esempio:
	if(i==j)
		f=g+h;
	else
		f=g-h;
	
	tradotto in assembly.

		bne	$s3, $s4, Else #Else è un'etichetta, non è realmente scritta in memoria
		add	$s0, $s1, $s2
		j	End_if
Else:	sub	$s0, $s1, $s2
End_if:	...

istruzione slt e sltu

Altro esempio:
if(i<j) ...


Vai con la seconda slide PDF
Formato istruzioni di tipo R: istruzioni aritmetico-logiche tra registri
op (opcode): tipo di istruzione,	6 bit (per le R sono tutti a 0)
rs: reg contenente il primo operando sorgente, 5b
rt: " " " secondo op. sorgente, 5b
rd: " " il risultato (destinazione),5b
shamt: shift amount, 5b
funct: variante dell'operazione, 6b (somma, sottrazione, ...)

Istruzioni di tipo I (lw, sw, addi, slti)
op 6 bit
rs 5b = reg base
rt 5b = reg dest.
indirizzo: 16 bit = spiazzamento, offset

istruzioni di salto condizionato (tipo i)

Giovedì 19 settembre 2019 (Stornaiuolo)
Continiuamo le slide di ieri.
Formato istruzioni di tipo J.

Per saltare ad indirizzi > 2^28 c'è un comando apposta
pseudoistruzione la (load address)
Le operazioni aritmetico-logiche si trovano nei registri
Registri sono vicini al processore, la memoria invece è distante e occorre che venga chiamata.


Terza slide

Passare da C (alto livello) ad Assembly (basso livello)

4 fasi per tradurre:
- analisi sintattica e trattamento errori (statico)
- generazione del codice macchina in forma simbolica
- ottimizzazione del codice macchina (facoltativo)
- assemblaggio (traduzione in codifica numerica) e linking 

Occhio alle pseudoistruzioni: istruzioni più astratte e intuitive ma devono essere tradotte per l'ISA, non sempre automatico.

Chiamate di sistema: syscall
	mettere il codice di chiamata nel reg $v0, argomenti da $a0 ad $a3
	chiamare la syscall
3 segmenti essenziali del processo:
	codice
	dati
	pila (stack (dall'alto al basso) e heap (dal basso verso l'alto))
Dichiarare i segmenti tipici
.global main = entry point
.data, .text

Esempio:
codice C: 	int a, b, c;
			a=b+c;
Assembly + mappatura:
	a: .word # la sua memoria sarà per le word 100, 101, 102, 103
	#.word è una macro
	lw $t0, 104($0) 

Array:
A: .space 80 # occupa 80 byte
In assembler per salvare le variabili ti devi salvare dello spazion in memoria
Variabile globale ha spazio statico ed è scritta in maiuscolo per convenzione, sono allocate in MIPS a partire dall'indirizzo 0x1000000
macro silde 28
Ci sono tutti i tipi, array, puntatori, struct.
Dichiarazione di funzione
Consideriamo fino a 4 parametri perché poi bisogna inventarsi dei trucchi
Il valore in uscita va restituito in v0
area di attivazione della funzione
I sottoprogrammi
-> creato record di attivaione sullo stack quando viene chiamato, deallocato alla sua fine
jump and link
side effect da gestire utilizzando la pila per salvare le informazioni
Problema: i registri sono condivisi sia dalla funzione chiamante che dalla chiamata (sovrascrittura). Per evitarlo, usare pila.
la pila serve per creare spazio per variabili locali della funzione
lo stack è una pila LIFO (last in, first out), indirizzata dai più grandi ai più piccoli.
Operazioni più utilizzate sono la push e la pop. Necessario avere puntatore in cima allo stack
Studiare la slide 47 della slide "gestione dello stack MIPS"
Implementazione della push e pop in assembly
PUSH: puntatore che punta alla cella successiva vuota, quindi per AUMENTARE la pila bisogna TOGLIERE indirizzi dallo stack pointer.
alla fine deallocare spazio nello stack (es. addi $sp, $sp, 24) =>aumentare lo stack pointer per deallocare dalla pila
Stack frame: area di attivazione.
Frame pointer è il punto di inizio della funzione. È un modo per deallocare in un colpo solo tutto quello che era usato dalla funzione.

Prologo del chiamante: salvo quello che mi serve.
Prologo del chiamato: salvo le mie info
Epilogo del chiamato: dealloco
Epilogo del chiamamnte: pulisco

Il chaiamnte si occupa di salvarsi dei registri temporanei, gli argomenti inviati alla funzione, i registri v0 e v1 (tutto ciò solo se necessario).
il chiamato salva i registri s0-s7 che sono quelli permanenti, per poi fare le operazioni che vuole; infine le rimette a posto una volta terminata l'esecuzione.
Quando la funzione chiamante non deve salvare nulla?
	Se al chiamante nessuno dei valori che normalmente si salva servono più, non li salva.
Quando la funzione chiamata non deve salvare nulla?
	Se il chiamato non deve sporcare i registri s0-s7
Ordine di salvataggio dei registri sullo stack (area di attivazione, slide 64)
precisazioni sul FP frame pointer
Procedura foglia è quella che non chiama nessun altro
Traduzione del fattoriale da C in assembly
Le funzioni non foglia si salvano sullo stack il ra return address


Martedì 24 settembre 2019
Esercizio di traduzione da C in assembler
Programma C che trova valore max in un array di valori

Trasformare la load address
la $t0, VETT
in una load word
lw, reg_dest, spiazzamento(reg_base)
lui

lui $t0, %hi(VETT) #la parte maggiore di vett (i primi 16 bit su 32 più significativi) è caricata (carico i 16 bit + significativi)
ori $t0, %lo(VETT) #faccio la or immediata tra $t0 e la parte bassa di VETT (che è a tutti 0), per rimette insieme i due pezzi
#in spiccioli, la istr. "la" si divide in lui e ori
altra traduzione di pseudoistruzione se ho spazio per 16 bit con istruzioni da 32
lw $t0, VETT
#spiazzamento, global pointer
lw $t0, %gp_al(VETT)($gp)

Adesso le funzioni: vedi ese3.asm


Mercoledì 25 settembre 2019

Assemblatore e linker
Traduzione programma da C a eseguibile:
1)Programma C
2)Programma assembler
3)Traduzione pseudoistruzioni in assembler
4)Traduzione riga per riga delle istruzioni in codifica binaria inserendo nella tabella dei simboli "etichette" di cui è necessario ricavare un indirizzo quando definite all'interno di un modulo
5) File oggetto: modulo in linguaggio macchina + funzioni libreria
6) Eseguibile: programma in linguaggio macchina -> memoria
Tabella dei simboli (utilizzata per i moduli).
Dove vengono salvati in memoria i moduli? Quando assemblo non lo so
Si assume che i moduli partano dall'indirizzo 0 della memoria
Il file oggetto è composto da:
	header(con dimensione in byte del file e la posizione dei vari segmenti)
	codice tradotto
	parte DATI statici
	informazioni di rilocazione (identificano istruzioni e dati che dipendono da indirizzi _assoluti_ durante l'esecuzione)
	informazioni per debug

La parte cruciale è inserire indirizzi alle etichette.
Può essere che una etichetta venga usata prima di essere definita.
Per cui il compilatore legge il file alla ricerca di etichette e le inserisce nella tabella dei simboli.

_Tabella dei simboli_ contiene:
	etichette associate alle direttive dell'assembly (.eqv) <symbol, value>
	ettichette che definiscono variabili nel segmento dati <symbol, relative address>
	e. che definiscono istruzioni di salto <symbol, address>
Indirizzi rilocabili perché calcolati rispetto al segmento di partenza (testo, dato)

_Tabella di rilocazione del modulo_
Contiene le informazioni sulle istruzioni tradotte in modo incompleto, c'est a dire le informazioni in cui il riferimento simbolico è una variabile del segmento dati, quindi convenzionalmente, l'assemblatore traduce le variabili scalari con 0($gp) (global pointer, che punta ad un'area del segmento dati).
Per i vettori la traduzione avviene tramite l'utilizzo della load address + or immediate (lui+ori), con immediati convenzionali a 0.
Le istruzioni di salto di tipo J, il simbolo è posto a 0 per convenzione.
La tabella è formata da entry di questo formato:
<indirizzo dell'istruzione, codice operativo della funzione, simbolo non risolto>

Esempio: sorgente procedura B:

.text
B:	bne $a0, $0, E
	sw $a0, Y
E:	la $t0, W

.data
Y:	.word 0

i riferimenti a W e Y sono nella tabella simboli
(VS_REL -IADDR_REL +4)/4 = istruzione di salto
Ho capito poco di questo esempio
La tabella di rilocazione contiene le informazioni con riferimenti al segmento dati e istruzioni con riferimenti assoluti
Questa breve parte è sull'appendice A del libro, caricata su beep
Linker: si occupa di mettere insieme i moduli, gestendo la memoria. Alla fine produce un file eseguibile con la memoria dei moduli ordinata. Assume quindi che il primo sta all'indirizzo 0, e poi gli altri a seguire in maniera sequenziale per codice e dati. A questo punto corregge le tabelle e traduce indirizzi.

Memoria virtuale
Se il programma è piccolo viene caricato tutto, se è grande viene caricato a pezzi.
Creo un modulo di memoria come riferimento per tutti.
Organizzazione della memoria:
	la prima parte è riservata dal SO
	quella dove sarà caricato il codice 0x0040 0000
	segmento dati statici: 0x1000 0000
	segmento dati (memoria RAM malloc)
	segmento stack. indirizzo max utilizzabile è 0x7FFF F(<-forse questa è una E)FFC
	$sp è un indirizzo preciso per prelevare dati statici

Il segmento dati statici non è rappresentabile su 16 bit.
Come faccio a rappresentare l'indirizzo 1001 0020?
Lo faccio a pezzi: il primo lo carico con la lui (load upper immediate) (0x1001) e il secondo con la lw $1 0x0020($s0)
ora per caricare in s1 il contenuto della cella al nostro indirizzo basta sommare i due pezzi con la ori
Rilocazione del modulo (solo per indirizzi relativi)

La memoria virtuale è quello che potenzialmente posso indirizzare (come memoria) per il programma

1) determinare la posizione in memoria dei moduli a partire dall'indirizzo 0 e poi in maniera sequenziale
2) creazione della tabella dei simboli globale costituita dall'unione delle tabelle di simboli di tutti i moduli che devono essere collegati, modificari (rilocati) in base all'indirizzo del modulo a cui appartengono
	Segmento dati =/= 
3) Correzione dei riferimenti nei moduli (*)
	ISTR
	IADDR
	VS: valore di S nella tabella globale
	GP: global pointer

Regole:
ISTR è in formato J(ump): inserise VS/4 nell'istr
	 è un salto in formato I: (VS-(IADDR+4))/4
	 è aritmetico/logica in formato I: inserire i 16 bit meno significativi di VS (VS_Low)
	 è di tipo load o store: inserisco VS - GP
	 è di tipo lui: inserisco i 16 bit più significativi di VS (VS_High)

Tabella di rilocazione dei moduli
Indirizzo	Istruzione
-File/modulo A
40 0000		lw $a0, 0($gp)	*
40 0004		beq $a0, $0, 0	*
40 0008		jal 0			*
-File/modulo B
40 000C		bne $a0, $0, 1
40 0010		sw $a0, 0($gp)	*
40 0014		lui $t0, 0		*
40 0018		ori $t0, $t0, 0	*
-Dati
A X 1000 0000	128
- W 1000 0004	0x12345678
B Y 1000 0008	0

Il professor Santambrogio ci parla delle iniziative al Campus Leonardo per gli studenti, complementari alla parte di studio

a questo punto ho il file eseguibile, salvato sul disco fisso, viene portato nella memoria centrale, presi gli argomenti di ingresso al main, registri inizializzati, caricati lo stack pointer e viene inserito nel PC l'indirizzo della prima istruzione da eseguire 
Caricamento dei parametri a0-a3
Cosa succede alle funzioni di libreria? Una volta il linker agganciava anche quelle all'eseguibile, adesso non più.
Le librerie vengono caricate dinamicamente quando il programma è in esecuzione (DLL: dynamic link library) e viene poi agganciata al programma

in questa lezioni ci ho capito molto poco

Giovedì 26 settembre 2019 (esercitazione col ragazzo)
Ricorsione, Assemblatore (e linker) varie (frame pointer, maschere bianrie, ...)

Ricorsione: MIPS con variabili intere a 32bit, fp (frame pointer = punta all'inizio dell'area memoria funzione. Di solito non viene usato se non in casi speciali) non in uso, variabili allocate nei registri, se possibile; si salvano solo i registri necessari

Svolgere i seguenti 4 punti:
vai a vedere 20190926/ese1.c e ese1.asm

esercizio nuovo, supponiamo di avere tanti moduli che devono essere assemblati in dei file oggetto. Problema sorge quando ci sono dei riferimenti esterni.

Esercizio assemblatore

All'esame sicuramente traduzione da C a assembly e poi un esercizio strano tipo
-utilizza mappe di bit/byte per recuperare il numero in memoria, se è a 0, ...
-questo che ci propone lui

Ci sono due moduli con delle cross-references e compilare le 3 tabelle tenendo contro dei due moduli
breve ripasso dei numeri decimali / esadecimali / binari
