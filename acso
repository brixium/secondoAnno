Architettura dei calcolatori e sistemi operativi 
Martedì 17 settembre 2019

Prof. Donatella Sciuto (vice rettore) + Luca Stornaiuolo
RIceve su appuntamento
Prova in itinere ma funziona un po'diversamente
Prima parte del corso: architettura dei calcolatori
	Testo: David A. Patterson, John L.Hennessy; Struttura e progetto dei calcolatori edito Zanichelli; ->architettura dei calcolatori
	Testo 2ndo sem: dispense online su BeeP.  ->sistemi operativi e programmazione concorrente (Linux)
TDE disponibili su BeeP. 
Lezione misto tra slide e lavagna

Modalità d'esame: 2 prove separate anche agli appelli: 1 sull'architettura dei calcolatori, l'altra sui sistemi operativi.
Ogni prova assegna 16 punti, la si passa con almeno 7 punti, 18 su tutte e due.
È possibile sostenere le prove in appelli differenti.
Sconsigliato fare le prove insieme.
All'esame ti danno tutto quello che dovresti impararti a memoria, tipo Bolchini.

Partiamo col singolo processore
Programmazione multithread, non vedremo problemi di design: sicurezza, surriscaldamento, efficienza energetica.
Architettura del calcolatore è coordinamento di molti livelli di astrazione.

Linguaggio di alto livello > Instruction Set Architecture > codice binario
ISA è relativo ad una architettura di CPU. Ed è quella che divide il sw dall'hw.
Il SO nasconde le funzioni hardware al software fornendo interfacce.
Firmware è la più vicina all'hardware
Transistor > circuiti > porte logiche >|| microarchitettura > ISA (architettura) > Sistema runtime(VM, OS, FS) ||> programma/linguaggio.
SO gestisce: processi, memoria e File System.

Livelli di astrazione:
C > assembly (MIPS) > linguaggio macchina (MIPS) > descrizione architettura hw a blocchi > descrizione circuito logico (diagrammi schematici dei circuiti).

Temi:
1) ISA (cpaitolo 2 fino a 2.14 e appendice A escluse le parti in Java)
	-linguaggio assembly (MIPS)
	-tradurre da C in assembly
	-tradurre dall'assembly al codice macchina
2)componenti hw:
	-porte logiche
	-circuiti combinatori
	-elemeti di memoria
3)il processore
4)la gerarchia di memoria (cap.5 fino a 5.4)
5)il bus: introduzione

il capitolo 5.7 verrà trattato nella seconda parte del corso con i sistemi operativi.

Legge di Moore: ogni 2 anni / 18 mesi, ci sono 2X transistor. Oggi il trend si è rallentato un po'per problemi di architettura.

Principi fondamentali:
	il programma viene mandato in esecuzione, lo si manda in memoria e si invia la prima istruzione al processore
	dopodiché esecuzione sequenziale
Architettura di Von Neumann
	|-CPU con ALU, Registri+PC, controllo
	|-Memoria
	|-Interfaccia di I/0 <-->memoria di massa
	|-I/0 <--> tastiera/video
	^ bus di dati, indirizzi e controllo (protocollo).

Struttura del data path:
Programma in c: 
int a, b, c;
c = a + b;
^ 1 istruzione in c che diventano 4 istruzione assmbly:
	.carica a da memoria a registro
	.carica b da mem a reg
	.esegui somma dei 2 registri
	.spostamento dell'output ALU da registro a memoria.
in altre parole: Caricare c, a e b nei registri in memoria, poi si portano nei registri di ingresso dell'ALU e si portano ai bus di ingresso all'ALU.

Categorie di istruzioni:
	Registro-memoria
		-trasferimento dati tra registri CPU e la memoria centrale
		-l'unità di informazione trasferita è la parola (word)
	Registro-registro
		-utilizzano il contenuto dei registri per svolgere operazioni (tramite ALU) e memorizzano il risultato in un ciclo di data path.
		-ciclo di data path

Esecuzione delle istruzioni
	Ciclo Fetch-Decode-Execute
			1)prendi l'istruzione corrente dalla memoria e la metti nel registro istruzioni (IR)
			2)incrementa il PC in modo da contenere l'indirizzo dell'istruzione successiva
			3)determina il tipo dell'istruzione corrente (decodifica)
			4)se l'istruzione usa una parola in memoria, determina dove si trova
			5)carica la parola in un registro CPU se necessario
			6)Esegui l'istruzione
			7)torna al punto 1 e esegue l'istruzione successiva

L'istruzione è divisa in campi:
	campo codice operativo indica il tipo di operazione
	gli altri campi indicano gli indirizzi degli operandi oppure gli operandi stessi. Gli indirizzi possono riferirsi ad indirizzi di memoria o reg della CPU.
modalità di indirizzamento

Noi usiamo MIPS a 32 bit 
2 tipi di processori: 
	quelli che vogliono entrambi i dati su cui operare provenienti dalla memoria debbano essere caricati nei registri -> architetture LOAD STORE (quelle più moderne)

Il normale flusso di esecuzione di un programma può essere interrotto da un segnale di INTERRUPT per richiesta di intervento che un dispositivo I/O manda al processore.
Con esso i dispositivi di I/O possono segnalare cose al processore.

Un po'di storia: RISC e CISC
I primi computer avevano delle ISA semplici, via via rese sempre più complesse.
Negli anni '70 andavano molto i processori microprogrammati CISC, realizzati con l'idea di fornire istruzioni molto complesse che rispecchiassero i costrutti dei liguaggi ad alto livello. Microprogramma per realizzare istruzioni complesse. Falsa credenza che avessero delle implementazioni HW più efficienti.
Negli anni '80 c'è stato l'avvento dei RISC, di cui il MIPS fa parte. Istruzioni semplici, tempi di esecuzioni molto brevi.
Vantaggi del RISC: spazio risparmiato per implementazione istruzioni extra viene impiegato per memorie cache per velocizzare istruzioni; uniformità delle istruzioni per velocizzarne la decodifica; uniformità e prevedibilità dei tempi di esecuzione delle istruzioni permette di eseguire più operazioni in parallelo.
Intel creò un nucleo RISC ma aggiunge in hardware un assembler che traduce dall'assembly CISC all'allora nuovo RISC.

Noi utilizziamo il MIPS (R2000/R3000 RISC)
Usando l'interprete MARS o SPIM possiamo farlo.

Registro da 32 bit, possiamo indirizzare fino a 2^32 B di memoria (4GB).
La memoria è indirizzabile a byte con parole da 4 byte.
Gli ultimi 2 bit alla fine della parola servono a poco.

Bus dati
Bus indirizzi
Bus di controllo

Esempio: operazione di lettura dalla memoria
	il bus indirizzi viene riempito con l'indirizzo della parola desiderata e inviato alla memoria
	quando la memoria ha finito di leggere la parola richiesta, il dato viene trasferito al bus dati e la CPU può prelevarlo
	nella struttura a bus singolo tutte le unità del calcolatore sono connesse al bus.

Ripasso numeri binari


CAPITOLO 2

Introduzione Assembler

Per il C la compilazione avviene in 3 fasi: compilazione (che crea file oggetto .obj), linking (con anche programmi di libreria), caricamento ed esecuzione.
Il linguaggio assembler è più primitivo: no controllo di flusso, solo GOTO. Linguaggio molto restrittivo (es. istruzioni aritmetiche hanno numero piccolo e fisso di operandi). Due processori con lo stesso linguaggio macchina hanno la stessa architettura anche con implementazioni hw diverse.
Incrementare il Program Counter lo fa avanzare di 4 (essendo a 32 bit).
I primi 6 bit indicano l'operazione da eseguire. I primi 6 bit a 0 indicano un'operazione aritmetica, descritta dagli ultimi 6 bit.
Utilizzando un traduttore inverso o disassemblatore posso tradurre dal linguaggio macchina in assembly.
I comandi con dei punti danno delle direttive all'assembler: 
	.text e .data indicano che le linee successive contengono istruzioni o dati
	.align n: indica l'allinamento su 2^n
	.global main: l'etichetta main è globale, ossia visibile dal codice in altri file
	.asciiz: area di memoria che memorizza una stringa terminata da 0
sw è store word
sd è store double
lw è load word
mul moltiplicazione
ble branch less or equal (salta se minore o uguale (sottointeso a 0))

Categoria di istruzioni:
	aritmetico logiche
	trasferimento memoria
	di controllo (flusso exec)
Esse hanno una codifica, un formato (nel MIPS ce ne sono 3, ciascuna per ciascuna categoria).
Le istruzioni del MIPS hanno solo 2 operandi e 1 risultato.
Sia operandi che risultato devono essere contenuti nel registro.
Non confondere variabili e registri. Variabili infinite, 32 registri codificati in bit, da 0 a 31. Sono numerati col $ davanti ($0, $1, ..., $31). Alcuni hanno dei nomi simbolici. $0 ha dentro 0, $1 è riservato (chiamato anche $at). I valori di ritorno sono salvati in $2 e $3, poi c'è il resto.


Mercoledì 18 settembre 2019

26enne Luca Stornaiuolo luca.stornaiuolo@polimi.it
Iscritto nel 2012, laurea triennale nel 2015. Si è iscritto ad una laurea magistrale ed era spaventato dall'ostacolo dell'inglese. Nel 2016 entra nel NECST (laboratorio basato sull'hardware). Hackaton. may 2017 NGC @San Francisco. 
Forze oscure: prof.Santambrogio, collaborazione IBM<->Polimi a Cambridge, Massachussets. Laurea magistrale a ottobre 2017.
Da nov.2017 dottorato: dura 3 anni e fai ricerca sull'ing.informatica.

Assembler MIPS
Libro di testo: Patterson Hennessy capitolo 2, usiamo MARS
In MIPS ci sono operandi e registri.
variabili =/= registri
I 3 tipi di istruzioni MIPS:
	(R)egister: operazioni aritmetico-logiche. Diverse istruzioni.
		istruzione destinazione, src1, src2
		add: serve per sommare il contenuto di due registri
			es: add rd, rs, rt //andrà a sommare rs e rt e metterà il risultato in rd.
		sub: sottrae
	(I)mmediate

	(J)ump

Esempio R: a = (b+c) - (d-f) + g.
$s1 è b, $s2 è c

trasferimenti con la memoria: istruzioni lw e sw

Load Word (LW)
lw carica il contenuto dalla memoria
es. lw $s1, 48($s2)
                ^base register che contiene il valore del base address
			 ^offset
		^dove va a salvare

SW è analogo a lw ma è store
es. sw $s1, 96($s2)
				^a questa locazione + offset viene assegnato il valore dentro s1

li e la, load immediate e load address
li $v0, 4 (carica la costante 4 in v0)
la $a0, num1 (carica l'indirizzo num1 in a0)

Differenza tra la e lw

Big endian e little endian. MIPS è in grado di operare con entrambi i metodi
Big endian è avere i byte enumerati da sinistra a destra, little endian è da destra a sinistra.

varianti dell'addizione: addi(immediata), addu (senza segno) e addiu (immediata e senza segno).

Esistono registri referenziabili e non referenziabili 
Moltiplicazione: mult rs rt, senza segno: multu rs rt
il registro del risultato della moltiplicazione è implicito. È messo in due registri speciali: hi e lo.
Il risultato della moltiplicazione si preleva dal registro hi e da lo tramite due operazioni: mfhi e mflo

Divisione: div e divu. Simile a prima

Istruzioni logiche
	and			and rd, rs1, rs2
	or			or rd, rs1, rs2
	nor			nor rd, rs1, rs2
	lshift		sll rd, rs, #bit
	rshift		srl rd, rs, #bit
esistono anche andi e ori ovvero and/or bit a bit tra un operando e una costante

Se devo fare una moltiplicazione per un multiplo di due uso lo shift a sinistra in un solo ciclo di clock anziché 4 o 6.
I bit inseriti durante lo shift sono settati a 0.

Array
L'indirizzo dell'iesimo elemento di un array si troverà nell'elemento br + (4*i) //4 sono il numero di byte in una word

(J)ump: istruzioni di salto.
Normalmente l'esecuzione è sequenziale.
Il Program Counter (PC) indica dove si trova la prossima istruzione da eseguire, quindi normalmente PC=PC+4.

Si può modificare il flusso di istruzioni con:
	-salto condizionato (branch) -> al verificarsi di una condizione viene eseguito. 
		Se la reg1==reg2: beq reg1, reg2, ind_salto
	-salto incondizionato (jump) -> viene sempre eseguito
		jump: j addr
		jump and link: jal
		jump register: jr reg

Etichette (labels)
vengono usate per essere ritrovate facilmente, l'assembler le sostitiusce in fase di compilazione

Esempio:
	if(i==j)
		f=g+h;
	else
		f=g-h;
	
	tradotto in assembly.

		bne	$s3, $s4, Else #Else è un'etichetta, non è realmente scritta in memoria
		add	$s0, $s1, $s2
		j	End_if
Else:	sub	$s0, $s1, $s2
End_if:	...

istruzione slt e sltu

Altro esempio:
if(i<j) ...


Vai con la seconda slide PDF
Formato istruzioni di tipo R: istruzioni aritmetico-logiche tra registri
op (opcode): tipo di istruzione,	6 bit (per le R sono tutti a 0)
rs: reg contenente il primo operando sorgente, 5b
rt: " " " secondo op. sorgente, 5b
rd: " " il risultato (destinazione),5b
shamt: shift amount, 5b
funct: variante dell'operazione, 6b (somma, sottrazione, ...)

Istruzioni di tipo I (lw, sw, addi, slti)
op 6 bit
rs 5b = reg base
rt 5b = reg dest.
indirizzo: 16 bit = spiazzamento, offset

istruzioni di salto condizionato (tipo i)

Giovedì 19 settembre 2019 (Stornaiuolo)
Continiuamo le slide di ieri.
Formato istruzioni di tipo J.

Per saltare ad indirizzi > 2^28 c'è un comando apposta
pseudoistruzione la (load address)
Le operazioni aritmetico-logiche si trovano nei registri
Registri sono vicini al processore, la memoria invece è distante e occorre che venga chiamata.


Terza slide

Passare da C (alto livello) ad Assembly (basso livello)

4 fasi per tradurre:
- analisi sintattica e trattamento errori (statico)
- generazione del codice macchina in forma simbolica
- ottimizzazione del codice macchina (facoltativo)
- assemblaggio (traduzione in codifica numerica) e linking 

Occhio alle pseudoistruzioni: istruzioni più astratte e intuitive ma devono essere tradotte per l'ISA, non sempre automatico.

Chiamate di sistema: syscall
	mettere il codice di chiamata nel reg $v0, argomenti da $a0 ad $a3
	chiamare la syscall
3 segmenti essenziali del processo:
	codice
	dati
	pila (stack (dall'alto al basso) e heap (dal basso verso l'alto))
Dichiarare i segmenti tipici
.global main = entry point
.data, .text

Esempio:
codice C: 	int a, b, c;
			a=b+c;
Assembly + mappatura:
	a: .word # la sua memoria sarà per le word 100, 101, 102, 103
	#.word è una macro
	lw $t0, 104($0) 

Array:
A: .space 80 # occupa 80 byte
In assembler per salvare le variabili ti devi salvare dello spazion in memoria
Variabile globale ha spazio statico ed è scritta in maiuscolo per convenzione, sono allocate in MIPS a partire dall'indirizzo 0x1000000
macro silde 28
Ci sono tutti i tipi, array, puntatori, struct.
Dichiarazione di funzione
Consideriamo fino a 4 parametri perché poi bisogna inventarsi dei trucchi
Il valore in uscita va restituito in v0
area di attivazione della funzione
I sottoprogrammi
-> creato record di attivaione sullo stack quando viene chiamato, deallocato alla sua fine
jump and link
side effect da gestire utilizzando la pila per salvare le informazioni
Problema: i registri sono condivisi sia dalla funzione chiamante che dalla chiamata (sovrascrittura). Per evitarlo, usare pila.
la pila serve per creare spazio per variabili locali della funzione
lo stack è una pila LIFO (last in, first out), indirizzata dai più grandi ai più piccoli.
Operazioni più utilizzate sono la push e la pop. Necessario avere puntatore in cima allo stack
Studiare la slide 47 della slide "gestione dello stack MIPS"
Implementazione della push e pop in assembly
PUSH: puntatore che punta alla cella successiva vuota, quindi per AUMENTARE la pila bisogna TOGLIERE indirizzi dallo stack pointer.
alla fine deallocare spazio nello stack (es. addi $sp, $sp, 24) =>aumentare lo stack pointer per deallocare dalla pila
Stack frame: area di attivazione.
Frame pointer è il punto di inizio della funzione. È un modo per deallocare in un colpo solo tutto quello che era usato dalla funzione.

Prologo del chiamante: salvo quello che mi serve.
Prologo del chiamato: salvo le mie info
Epilogo del chiamato: dealloco
Epilogo del chiamamnte: pulisco

Il chaiamnte si occupa di salvarsi dei registri temporanei, gli argomenti inviati alla funzione, i registri v0 e v1 (tutto ciò solo se necessario).
il chiamato salva i registri s0-s7 che sono quelli permanenti, per poi fare le operazioni che vuole; infine le rimette a posto una volta terminata l'esecuzione.
Quando la funzione chiamante non deve salvare nulla?
	Se al chiamante nessuno dei valori che normalmente si salva servono più, non li salva.
Quando la funzione chiamata non deve salvare nulla?
	Se il chiamato non deve sporcare i registri s0-s7
Ordine di salvataggio dei registri sullo stack (area di attivazione, slide 64)
precisazioni sul FP frame pointer
Procedura foglia è quella che non chiama nessun altro
Traduzione del fattoriale da C in assembly
Le funzioni non foglia si salvano sullo stack il ra return address


Martedì 24 settembre 2019
Esercizio di traduzione da C in assembler
Programma C che trova valore max in un array di valori

Trasformare la load address
la $t0, VETT
in una load word
lw, reg_dest, spiazzamento(reg_base)
lui

lui $t0, %hi(VETT) #la parte maggiore di vett (i primi 16 bit su 32 più significativi) è caricata (carico i 16 bit + significativi)
ori $t0, %lo(VETT) #faccio la or immediata tra $t0 e la parte bassa di VETT (che è a tutti 0), per rimette insieme i due pezzi
#in spiccioli, la istr. "la" si divide in lui e ori
altra traduzione di pseudoistruzione se ho spazio per 16 bit con istruzioni da 32
lw $t0, VETT
#spiazzamento, global pointer
lw $t0, %gp_al(VETT)($gp)

Adesso le funzioni: vedi ese3.asm


Mercoledì 25 settembre 2019

Assemblatore e linker
Traduzione programma da C a eseguibile:
1)Programma C
2)Programma assembler
3)Traduzione pseudoistruzioni in assembler
4)Traduzione riga per riga delle istruzioni in codifica binaria inserendo nella tabella dei simboli "etichette" di cui è necessario ricavare un indirizzo quando definite all'interno di un modulo
5) File oggetto: modulo in linguaggio macchina + funzioni libreria
6) Eseguibile: programma in linguaggio macchina -> memoria
Tabella dei simboli (utilizzata per i moduli).
Dove vengono salvati in memoria i moduli? Quando assemblo non lo so
Si assume che i moduli partano dall'indirizzo 0 della memoria
Il file oggetto è composto da:
	header(con dimensione in byte del file e la posizione dei vari segmenti)
	codice tradotto
	parte DATI statici
	informazioni di rilocazione (identificano istruzioni e dati che dipendono da indirizzi _assoluti_ durante l'esecuzione)
	informazioni per debug

La parte cruciale è inserire indirizzi alle etichette.
Può essere che una etichetta venga usata prima di essere definita.
Per cui il compilatore legge il file alla ricerca di etichette e le inserisce nella tabella dei simboli.

_Tabella dei simboli_ contiene:
	etichette associate alle direttive dell'assembly (.eqv) <symbol, value>
	ettichette che definiscono variabili nel segmento dati <symbol, relative address>
	e. che definiscono istruzioni di salto <symbol, address>
Indirizzi rilocabili perché calcolati rispetto al segmento di partenza (testo, dato)

_Tabella di rilocazione del modulo_
Contiene le informazioni sulle istruzioni tradotte in modo incompleto, c'est a dire le informazioni in cui il riferimento simbolico è una variabile del segmento dati, quindi convenzionalmente, l'assemblatore traduce le variabili scalari con 0($gp) (global pointer, che punta ad un'area del segmento dati).
Per i vettori la traduzione avviene tramite l'utilizzo della load address + or immediate (lui+ori), con immediati convenzionali a 0.
Le istruzioni di salto di tipo J, il simbolo è posto a 0 per convenzione.
La tabella è formata da entry di questo formato:
<indirizzo dell'istruzione, codice operativo della funzione, simbolo non risolto>

Esempio: sorgente procedura B:

.text
B:	bne $a0, $0, E
	sw $a0, Y
E:	la $t0, W

.data
Y:	.word 0

i riferimenti a W e Y sono nella tabella simboli
(VS_REL -IADDR_REL +4)/4 = istruzione di salto
Ho capito poco di questo esempio
La tabella di rilocazione contiene le informazioni con riferimenti al segmento dati e istruzioni con riferimenti assoluti
Questa breve parte è sull'appendice A del libro, caricata su beep
Linker: si occupa di mettere insieme i moduli, gestendo la memoria. Alla fine produce un file eseguibile con la memoria dei moduli ordinata. Assume quindi che il primo sta all'indirizzo 0, e poi gli altri a seguire in maniera sequenziale per codice e dati. A questo punto corregge le tabelle e traduce indirizzi.

Memoria virtuale
Se il programma è piccolo viene caricato tutto, se è grande viene caricato a pezzi.
Creo un modulo di memoria come riferimento per tutti.
Organizzazione della memoria:
	la prima parte è riservata dal SO
	quella dove sarà caricato il codice 0x0040 0000
	segmento dati statici: 0x1000 0000
	segmento dati (memoria RAM malloc)
	segmento stack. indirizzo max utilizzabile è 0x7FFF F(<-forse questa è una E)FFC
	$sp è un indirizzo preciso per prelevare dati statici

Il segmento dati statici non è rappresentabile su 16 bit.
Come faccio a rappresentare l'indirizzo 1001 0020?
Lo faccio a pezzi: il primo lo carico con la lui (load upper immediate) (0x1001) e il secondo con la lw $1 0x0020($s0)
ora per caricare in s1 il contenuto della cella al nostro indirizzo basta sommare i due pezzi con la ori
Rilocazione del modulo (solo per indirizzi relativi)

La memoria virtuale è quello che potenzialmente posso indirizzare (come memoria) per il programma

1) determinare la posizione in memoria dei moduli a partire dall'indirizzo 0 e poi in maniera sequenziale
2) creazione della tabella dei simboli globale costituita dall'unione delle tabelle di simboli di tutti i moduli che devono essere collegati, modificari (rilocati) in base all'indirizzo del modulo a cui appartengono
	Segmento dati =/= 
3) Correzione dei riferimenti nei moduli (*)
	ISTR
	IADDR
	VS: valore di S nella tabella globale
	GP: global pointer

Regole:
ISTR è in formato J(ump): inserise VS/4 nell'istr
	 è un salto in formato I: (VS-(IADDR+4))/4
	 è aritmetico/logica in formato I: inserire i 16 bit meno significativi di VS (VS_Low)
	 è di tipo load o store: inserisco VS - GP
	 è di tipo lui: inserisco i 16 bit più significativi di VS (VS_High)

Tabella di rilocazione dei moduli
Indirizzo	Istruzione
-File/modulo A
40 0000		lw $a0, 0($gp)	*
40 0004		beq $a0, $0, 0	*
40 0008		jal 0			*
-File/modulo B
40 000C		bne $a0, $0, 1
40 0010		sw $a0, 0($gp)	*
40 0014		lui $t0, 0		*
40 0018		ori $t0, $t0, 0	*
-Dati
A X 1000 0000	128
- W 1000 0004	0x12345678
B Y 1000 0008	0

Il professor Santambrogio ci parla delle iniziative al Campus Leonardo per gli studenti, complementari alla parte di studio

a questo punto ho il file eseguibile, salvato sul disco fisso, viene portato nella memoria centrale, presi gli argomenti di ingresso al main, registri inizializzati, caricati lo stack pointer e viene inserito nel PC l'indirizzo della prima istruzione da eseguire 
Caricamento dei parametri a0-a3
Cosa succede alle funzioni di libreria? Una volta il linker agganciava anche quelle all'eseguibile, adesso non più.
Le librerie vengono caricate dinamicamente quando il programma è in esecuzione (DLL: dynamic link library) e viene poi agganciata al programma

in questa lezioni ci ho capito molto poco

Giovedì 26 settembre 2019 (esercitazione col ragazzo)
Ricorsione, Assemblatore (e linker) varie (frame pointer, maschere bianrie, ...)

Ricorsione: MIPS con variabili intere a 32bit, fp (frame pointer = punta all'inizio dell'area memoria funzione. Di solito non viene usato se non in casi speciali) non in uso, variabili allocate nei registri, se possibile; si salvano solo i registri necessari

Svolgere i seguenti 4 punti:
vai a vedere 20190926/ese1.c e ese1.asm

esercizio nuovo, supponiamo di avere tanti moduli che devono essere assemblati in dei file oggetto. Problema sorge quando ci sono dei riferimenti esterni.

Esercizio assemblatore

All'esame sicuramente traduzione da C a assembly e poi un esercizio strano tipo
-utilizza mappe di bit/byte per recuperare il numero in memoria, se è a 0, ...
-questo che ci propone lui

Ci sono due moduli con delle cross-references e compilare le 3 tabelle tenendo contro dei due moduli
breve ripasso dei numeri decimali / esadecimali / binari


Martedì 1 ottobre 2019

Architettura del processore

Progettare il processore MIPS. Servono gli oggetti base elettronici, principalmente transistor che immaginiamo binari ma in realtà ci sono due livelli di tensione, basso (0 V) e alto (1.8 V). Noi utilizzeremo dei circuiti elementari, non scendiamo ai transistor.
Noi utilizzeremo dei circuiti elementari, non scendiamo ai transistor.
Due grandi classi di circuiti elementari:
	- combinatori: il circuito produce un'uscita nello stesso istante dell'ingresso (semplici) ma non hanno memoria (l'uscita è in funzione dell'ingresso).
	- sequenziali: l'uscita al tempo t è funzione degli ingressi al tempo t ma anche dello stato, la storia degli eventi passati

cenno di porte logiche.
Specifica delle funzionalità->rete logica
Algebra di commutazione è il punto di partenza. È parte dell'algebra booleana e utilizza solo 0 e 1.
Variabili logiche possono assumere solo valore 0 oppure 1. x=0 se x=/=1 e viceversa.
Operatori:
	negazione: NOT f(x)=0 => x=1; f(x)=1 => x=0.
	somma logica: OR f(x,y)=0 => x=y=0 else f(x,y)=1
	prodotto logico: AND f(x,y)=1 => x=y=1 else f(x,y)=0
(sono raccolte nelle tabelle di verità)

Proprietà fondamentali dell'algebra di commutazione
____________________________________________________________________
				|	AND(*)			|	OR(+)						|
----------------|-------------------|-------------------------------|
identità		|	1*x=x			| 0+x=x							|
elemento nullo	|	0x=0			| 1ORx=x						|
idempotenza		|	X*X=X			| XORX=X						|
inverso			|	X AND (!X)=0	| XOR(!X)=1						| (! è il negato)
assorbimento	| X AND (X+Y)=X		| X+X*Y=X						| (serve per semplificare)
pr.commutativa	| XY = YX			| XORY = YORX					|
pr.associativa	| (XY)Z = X(YZ)		| (X+Y)+Z = X+(Y+Z)				|
pr.distributiva	| X(Y+Z)=XY+XZ		| X+YZ=(X+Y)(X+Z)				|
teo.di De Morgan| !(X*Y)=!X+!Y		| !(X+Y)=!X*!Y					|
teo del consenso| XY+!XZ+YZ=XY+!XZ	| (X+Y)(!X+Z)(Y+Z)=(X+Y)(!X+Z)	|
--------------------------------------------------------------------|

Prova a semplificare questa funzione applicando questi teoremi
f = A+!AB+!ABC =(mia soluzione)= A(1+0B+0BC) = A sbagliata
SOLUZIONE CORRETTA: applicando la proprietà distributiva + identità = A+!AB(1+C) = per propr. elemento nullo = A+!AB1 = applico propr.distributiva = (A+!A) (A+B) = 1*(A+B) = A OR B

Specifica della funzionalità può essere fornita come:
	tabella delle verità
	funzione logica
	rete logica 
Esempio:
Per esprimere 3 uscite devo dare 3 eq.logiche. Come faccio a scrivere la funzione logica da una descrizione a parole
Supponiamo che l'uscita D assume valore 1 sse almeno uno dei 3 ingressi ha valore 1, l'uscita F assume 1 sse tutti e 3 gli ingressi hanno valore 1 e l'uscita E assume valore 1 sse esattamente 2 ingressi hanno valore 1.
Risposta:
L'uscita D si esprime con: A OR B OR C = D
L'uscita F diventa: A AND B AND C = F
L'uscita E è un po'più complessa. A*B=1, C deve essere 0 (1/3 caso)
_tabella_
A B C | E D F
0 0 0 |	0 0 0
0 0 1 |	0 1 0
0 1 0 |	0 1 0
0 1 1 |	1 1 0
1 0 0 |	0 1 0
1 0 1 |	1 1 0
1 1 0 |	1 1 0
1 1 1 |	0 1 1
---------
Quindi E = !ABC+A!BC+AB!C

Disegni delle porte logiche:
NOT è un triangolo con 1 ingresso che ha un pallino (base) ed 1 uscita (punta). (spesso si usa solo il pallino senza triangolo)
OR è una punta di freccia: le entrate nella parte concava, l'uscita nella freccia
AND è un semicerchio con gli ingressi nel piatto e 1 uscita

Esempio A+B+C. Sono eseguite prima A+B e poi il risultato + C se ho un operatore binario, se è ternario uso una porta a 3 ingressi. Ci ci mette più tempo sono i segnali A e B che devono attraversare due porte, mentre C una sola
Esempio A*B*C che diventa (A*B)*C.
Esempio dell'uscita E=!ABC+A!BC+AB!C di prima. Cammino + lungo è quello di A che si fa 1 not, 2 and e 2 or

NAND (NOT AND) e NOR (NOT OR) sono operatori funzionalmente completi
Con il NAND posso realizzare il NOT, l'AND e l'OR
___NAND____
X Y | !(XY)
----|------
0 0 |	1
0 1 |	1
1 0 |	1
1 1 |	0

___NOR_____
X Y | !(X+Y)
----|-------
0 0 |	1
0 1 |	0
1 0 |	0
1 1 |	0

Come si fa un NOT usando un NAND? Così: !(XX) = !X+!X = !X
AND si fa mettendo NOT dopo il NAND. Così: !!(XY) = XY
OR con NAND: X+Y = !(!X !Y)
Altri operatori sono lo XOR (OR esclusivo) e XNOR
XOR si disegna come una doppia punta di freccia.
__XOR____
X Y | XOR
0 0 |	0
0 1 |	1
1 0 |	1
1 1 |	0

___XNOR___
X Y | XNOR
0 0 |	1
0 1 |	0
1 0 |	0
1 1 |	1

Scrivere la XOR con solo NOT, AND e OR
f = (x*!y) || (!x*y)
Scrivere la XNOR con solo NOT, AND e OR
f = !(X*Y) || (X*Y)

Per costruire la notazione dal disegno si va da sinistra a destra e si compone
Specifica a parole
	\->Tabella delle verità
		\->Funzione logica

Esercizio:
X Y Z | f
------|---
0 0 0 | 0
0 0 1 | 0
0 1 0 | 0
0 1 1 | 0
1 0 0 | 1
1 0 1 | 0
1 1 0 | 1
1 1 1 | 1
Prendo i 3 termini che la funzione mette a 0 e uso la prima forma canonica sottostante.
1 0 0 lo esprimo come X*!Y*!Z
1 1 0 si esprime come X*Y*!Z
1 1 1 lo scrivo come X*Y*Z
Infine faccio la somma logica di questi tre termini
f = (X*!Y*!Z)+(X*Y*!Z)+(X*Y*Z)
^^questa formula si può semplificare di molto usando le reogle qui sotto.
Adesso risolvo con la seconda forma canonica:
X|Y|Z & X|Y|!Z & X|!Y|Z & X|!Y|!Z & !X|Y|!Z
^^anche qui può essere semplificato
f = X(Y+!Z) <-funzione semplificata

Esistono 2 forme standard per semplificare le funzioni logiche
1ma forma canonica: 
	Ogni funzione f può essere specificata mediante la somma logica (OR) di tutti e soli i termini prodotto (AND) delle variabili di ingresso corrispondenti al valore 1 assunto dalla funzione
	Termine prodotto (MINTERMINE): prodotto logico (AND) di tutte le variaibli in ingresso della funzione prese in forma naturale se sono = 1, e in forma negata se sono = 0 nella configurazione di ingresso
2nda forma canonica (è duale della prima):
	f può essere espressa come il prodotto logico (AND) dei termini somma (OR) delle variabili in ingresso corrispondenti agli zeri della funzione e il termine somma, che viene chiamato anche MAXTERMINE, è la somma logica delle variabili in ingresso in forma naturale se hanno valore 0 e in forma complementata se hanno valore 1

Domani vediamo i componenti combinatori


Mercoledì 2 ottobre 2019
Sintesi combinatoria
Data una specifica, possiamo usare una tabella delle verità (solo quando ci sono pochi ingressi) oppure con la equazione logica.
Dalla tabella delle verità si può ricavare l'equazione con la prima e la seconda forma canonica. Prima è somma di prodotti e la seconda è un prodotto di somme. Questa rappresentazione non è ottima perché non ha il numero minimo di variabili.
Esemio di ieri: f = x(!y)(!z)+xy(!z)+xyz
					1  0  0  ,1 1 0, 111
È semplificabile utilizzando la proprietà sitributiva -> f=x(!y!z+y!z+yz).
Applico di nuovo la stessa pr. -> f=x(!z(!y+y)+yz) ->(mi avvalgo del fatto che !y+y=1 e 1*j=j) f=x(!z+yz)
A questo punto applico la proprietà dell'assobimento al contrario: !z=!z+y*!z
f=x(!z+y!z+yz) =x(!z+y(!z+z))=x(!z+y)

Blocchi combinatori (slide "Il livello logico digitale" disponibile online)
I tipici blocchi funzionali combinatori sono:
	1)multiplexer (MUX): ogni ingresso è numerato, c'è un ingresso di selezione che decide l'uscita. A forma di trapezio.
		Esempio MUX: 1 ingresso di selezione, 2 input, 1 output. L'ingresso di seleziona determina l'output. Tabella verità:
I1 |I2 |SEL|OUT
---------------
0	0	0	0
0	1	0	0
1	0	0	1
1	1	0	1
0	0	1	0
0	1	1	1
1	0	1	0
1	1	1	1
		In questo caso la formula logica è: C=!SA+SB. Dove C è l'uscita, S è la selezione, A è il primo ingresso e B il secondo ingr.
		Esempio se il MUXer ha più di 2 ingressi (4 in questo caso), dovraà avere più ingressi di selezione (in questo caso 2 (2^2))
		Se voglio un muxer a 2 ingressi dati da k bit devo mettere in cascata più muxer semplici da 2 ingressi che hanno tutti la medesima selezione in input.
		
	2)demultiplexer (DEMUX): meno ingressi, più uscite e controllo. Il controllo decide dove inviare l'uscita
	tabella verità
	I S1 S2 01 02 03 04
	D 0  0  D  0  0  0
	D 0  1  0  D  0  0
	D 1  0  0  0  D  0
	D 1  1  0  0  0  D

	3)Decodificatore (DECoder)
		non fa passare un dato ma determina l'uscita a seconda degli ingressi (inngressi < uscite)
		tab verità:
		i1|i2|u0|u1|u2|u3|
		0 |0 |1 |0 |0 |0
		0 |1 |0 |1 |0 |0
		1 |0 |0 |0 |1 |0
		1 |1 |0 |0 |0 |1
		con le porte logiche si fa mettendo degli and in cascata con alcuni not davanti. Tanti and quante uscite
	4)Comparatore o confrontatore:
	Ha due gruppi di ingressi A e B da n>=1 bit ciascuno e 3 uscite: a<b, a>b e a=b. Sulle slide esempio di confrontatore di numeri a 2 bit. Se i numeri in ingresso da A e da B hanno 2 bit, due ingressi per ciascun gruppo, le uscite sono sempre 3.

	5)Shifter combinatorio: (sempre di 1 posizione)
		1)scorrimento verso sinistra (moltiplicazione *2: aggiungere uno zero da destra)
		2)scorrimento verso destra   (divisione *2: aggiungere uno zero da sinistra)
		S/!D indica in che direzione shiftare (0=verso destra, 1=verso sinistra)
				Lshift		Rshift
		Out(n)	I(n-1)		New bit(0)
		Out(i)	I(i-1)		I(i+1)
		Out(0)	new bit(0)	I(1)
	Componenti aritmetici (somma e sottrazione)
	6)Sommatore o addizionatore: half adder (semisommatore) e full adder 
		Half adder ha due ingressi e due uscite. In ingresso i due numeri e in uscita la somma (XOR) e il riporto (carry)
		\-> è come fare la somma in colonna. Sum = A(XOR)B, carry= A&B
		Full adder: ha 3 ingressi (2 numeri e carry) e 2 uscite: sum e carry
		\-> sum=A(XOR)B^carry (^ è xor), il carry out sarà: ABCarryin+AB!carryin+A!Bcarryin+!ABcarryin che semplificato diventa A(B+carryin)+Bcarryin
		Per un semplice sommatore a k bit bisogna fare un half adder all'inzio e poi full adder fino alla fine. Problema delle prestazioni: il cammino più lungo è quello del carry che fa aspettare tutti i full carry. Nella realtà i calcolatori hanno un circuito che predica il carry. Questo sistema si chiama "carry look ahead".
		Moltiplicatore Dadda è figlio del prof.Dadda del PoliMi
		Noi vediamo il sommatore come una scatola chiusa.

		Sottrattore. Analogamente al sommatore ci sono: semi-sottrattore e sottrattore intero
Problemino: in ingresso due numeri interi naturali positivi a k bit e un ingresso di controllo. in uscita un numero intero binario naturale Z da k bit. Su Z deve presentarsi la somma A+B se C=0, la differenza A-B se C=1. In hardware questa cosa si fa in modo diverso dal software, che controlla prima l'ingresso di controllo. Si fa prima sia la somma e la sottrazione e poi se vede cosa mandare in output, attravero un multiplexer che riceve in ingresso somma e sottrazione e in controllo C. L'uscita sarà Z. È lo stesso modo in cui ragiona l'unità aritmetico-logica del processore (ALU) che sanno fare somma in C2, AND, OR, NOT e comparatore.
Esempio ALU a 2 bit e 2 bit di controllo con multiplexer.
Nell'appendice B troviamo:
	Numeri reali espressi in IEEE754
	Il segnale di zero
	L'indispensabile _Overflow Detection_

Esercizi su parte combinatoria e sequenziale.
1) overflow. Progettare circuito combinatorio che segnali overflow di una somma di numeri in complemento a due. Qui ci viene in mente la Bolchini: overflow non si verifica se gli operandi hanno segno discorde. Se gli operandi hanno segno uguale ma il risultato ha segno opposto, si è verificato overflow.
Tabella verità. s1: bit + significativo 1mo operando, s2: bit + significativo 2ndo operando, sr: bit + sign. risultato
s1|s2|sr|OvF
0 |0 |0 |0
0  0  1 |1
0  1  0 |0
0  1  1 |0
1  0  0 |0
1  0  1 |0
1  1  0 |1
1  1  1 |0

Scrivere la prima forma canonica di ciò. OvF=(!s1*!s2*sr) + (s1*s2*!sr)
Disegnare il circuito
2)Rete combinatoria con 3 ingressi (A, B, C) e 2 uscite (C1 e C0)
Le due uscite devono rappresentare in binario naturale (intero) il conteggio del numero di uni presenti sugli ingressi ABC
tabella verità:
 |A|B|C|C1|C0
0|0|0|0|0 |0
1|0|0|1|0 |1
2|0|1|0|0 |1
3|0|1|1|1 |0
4|1|0|0|0 |1
5|1|0|1|1 |0
6|1|1|0|1 |0
7|1|1|1|1 |1
1ma forma canonica:  C0 = (!A!BC)+(!AB!C)+(A!B!C)+(ABC); C1= !ABC+A!BC+AB!C+ABC
2nda forma canonica (vado a vedere gli zeri della funzione, normali se =0, negati e =1):
C0 = (A+B+C)*(A+!B+!C)*(!A+B+!C)*(!A+!B+C)
C1 = (A+B+C)*(A+B+!C)*(A+!B+C)*(!A+B+C)
La tabella fuò essere fornita vuota ma ti viene detto "la funzione C0 è caratterizzata dai seguenti MINTERMINI (= per quali configurazioni di ingresso l'uscita vale 1): 1,2,4,7, MINTERINI della funzione C1: 3, 5, 6, 7"

Ritardo massimo (misurato su 1 segnale) se NOT=1ns, AND=2ns, OR=3ns
C0 ha 1 NOT, 2 AND, 2 OR = 1+4+6=11ns
Una porta a N ingressi è implementata da N-1 porte a 2 ingressi.

Semplificare le funzioni.
Consiglio: se ho una funzione con termini dispari, fare in modo che diventi pari. In che modo? Con la proprietà di idempotenza (x=x+x).
G(a,b,c) = !a!b!c+!a!bc+!ab!c
	1)applico idempotenza: !a!b!c+!a!bc+!ab!c+!a!b!c
	2)applico pr.distributiva: !a!b(!c+c)+!a!c(b+!b)
	3)siccome !c+c = 1 e b+!b=1 ho:  !a!b+!a!c = !a(!b+!c)

z = !((A^B)+(C^D)) . Cosa faccio? Prima cosa: ESPANDO lo XOR. A^B = A!B+!AB

Martedì 8 ottobre 2019

Circuiti sequenziali. È così se le sue uscite non dipendono solamente dagli ingressi ma dallo stato, cioè dal comportamento passato.
Una stessa configurazione in ingresso applicata in istanti diversi produrrà un uscita diversa.
u(t) = f(i(t), stato)
Lo stato contiene l'info passato dal circuito.
È bistabile: el. di mem. in grado di memorizzare un bit di informazione.
          ______________
--------->|Circuito    |
ingresso  |combinatorio|------>uscita
      /-->|____________|--------
	  |                        |
	  |stato attuale           |stato futuro
	  |                        |
	  _______________________  |
      |                     |  |
	  | Elementi di memoria |<-/
	  |_____________________|
I bistabili esistono sincroni e asincroni.
	Asincroni: stato cambia ad ogni evento sul segnale di ingresso in qualunque istante di tempo.
	Sincroni: sensibili ad un segnale di controllo di sincronizzazione (il nostro è il clock). Sincronizzazione uscite / transizione di stato avviene solo in corrispondenza di eventi sul segnale di sync (controllo).
		Due tipi di bistabili sincroni: Gated lech e flip flop.
			Gated lech sono controllati.
			Flip flop sono di 2 tipi: master-slave e edge-triggered

I bistabili sono fatti con il bistabile SR asincrono.
Per sapere come funziona bisogna avere a mente la porta logica NOR (tutti 0 in uscita, tranne quando in ingresso ci sono tutti 1).
Il bistabile SR asincrono ha 2 ingressi esterni (S e R), due NOR e due uscite !Q e Q. Se S e R l'uscita rimane quella del passato.
S | R | Q |!Q | (SET, RESET, Q, Q negato)
0 | 0 | Q |!Q | (se Q=1 in partenza, rimane 1; se invece Q=0, Q rimane 0 e Q!=1)
0 | 1 | 0 | 1 | (indipendentemente dall'uscita precedente)
1 | 0 | 1 | 0 | (indipendentemente dall'uscita precedente)
1 | 1 | 0 | 0 | (ha poco senso fare set e reset insieme, ma se lo faccio ha un comportamento indesiderato / non previsto. EVITARE)

Altro modo per rappresentare il bistabile è un diagramma temporale. Sulle ascisse tempo, sulle ordinate R, S e Q.
 ^
.|______         ______ 1
Q|      \_______/       0
.|__             __     1
S|  \___________/  \___ 0
.|        __            1
R|_______/  \___________0
.|
 |---------------------->t

Nei bistabili sincroni nel grafico c'è anche il clock da considerare sull'asse verticale.
Bistabile SR sincrono (latch SR)
Si aggiungono 2 porte AND davanti per il clock
Temporizzato a livello.

R-----|AND)---
clock-/        Qui il resto del grafico è uguale a quello precedente.
      \
S-----|AND)---

C | S | R | Q |!Q|
--|---|---|---|--|
0 | X | X | Q |!Q| (X = don't care)
1 | 0 | 0 | Q |!Q| quando il livello è a 1 tutto il cambiamento passa secondo il comportamento dettato dall'SR asincrono.
1 | 0 | 1 | 0 | 1|
1 | 1 | 0 | 1 | 0|
1 | 1 | 1 | 0 | 0|

Bistabile D sincronizzato

Dove D è il dato che verrà sincronizzato

\
 \D
  \______
   |     |AND)
   |    /
   |C--/
   |   \
   |    \
   \-NOT-|AND)

C|D|Q|!Q
-|-|-|--
0|X|Q|!Q
1|0|0| 1
1|1|1| 0

Ritardo di propagazione
Problema del fenomeno di trasparenza (indesiderato). Per risolverlo utilizziamo i flip-flop.
Vantaggio di usare il fronte anziché il livello del clock

Comandi di ripristino: CLR (clear, imposta a 0 e quello che imposta a 1).
I flip flop sono fatti da 2 o 3 bistabili

Flip-flop D master-slave 
Il master è il primo (principale), lo slave quello in cascata (ausiliario). È una coppia di bistabili sincroni D trasparenti in cascata con clock invertiti; l'insieme dei due non presenta il fenomeno di trasparenza

Edge-triggered D flip-flop
È meno costoso del precedente perché usa una OR
Costo totale: 6 nor + 1 or
Il cambiamento si vede sul fronte di uscita

D C Q !Q
0 1 Q !Q

Sia il master-slave e che l'edge triggered sono identici per quanto riguarda l'uscita

Giovedì 10 ottobre 2019

ACSO esercitazioni, esercizi reti - reti sequenziali
Rete combinatoria
Le uscite dipendono direttamente dagli ingressi
Reti sequenziali
Bistabile SR asincrono
(FPGA)
Esercizio TDE

Martedì 15 ottobre 2019
Architettura MIPS
Prelievo istruzione da memoria e incremento PC->lettura 2 registri->operazioni ALU, che possono essere varie.
Register file, 2 richieste lettura 1 in scrittura
leggi appunti cartacei



-----------------
Seconda parte: SISTEMI OPERATIVI
Martedì 12 novembre 2019
S.O. multitasking o multiprocesso: possono esserci più processi in esecuzione simultaneamente, seppure la CPU è una sola.
Due modi per multitasking: tramite processi o tramite thread
Macchina virtuale
File system alla fine del corso

Il SO è in grado di virtualizzare i processi e far credere loro che occupino interamente le risorse, ma è il SO che le alloca.
Con questa soluzione non si può interagire direttamente con l'HW ma ci si deve affidare alle chiamate di sistema, solitamente integrate in delle librerie.
Il SO non è monolitico ma anche lui è composto da più processi.
Come creare processi?
	-> chiamate di sistema per gestirli
Primitive di gestione processi
Ogni processo ha il proprio PID (Process IDentifier) univoco.
Differenze tra programma e processo?
Processo fatto da 3 parti:
	1) segmento codice (text segment)
	2) s. dati (data) che contiene tutte le variabili globali e statiche, locali sulla pila e dinamiche con la malloc
	3) s. di sistema: contiene dati che servono al SO per gestire il programma in esecuzione
A parte init che non ha un processo padre, tutti gli altri ce l'hanno. Un processo padre può creare i processi figli.
Non c'è alcuna relazione tra fratelli
Per generare un processo figlio esiste la funzione fork(), che crea un clone esatto del padre nel momento in cui viene creato

pid_t fork();	//pid_t è un intero. La funzione restituisce al padre il PID assegnato al figlio, il figlio restituisce 0.
pid_t getpid(); // è una funzione che restituisce a chi la invoca il suo PID
void exit(int code); //funzione di exit termina il programma e restituisce un codice al padre

void main(){
	pid_t pid1, pid2;
	pid1 = fork(); //a questo punto esistono 2 processi con pid1 e pid2. SI distinguono perché il padre in pid1 ha il PID del figlio, il figlio ha 0.
	if(pid1 == 0){ // siamo sicuri che solo il processo figlio eseguirà questa istruzione
		printf("Figlio PID: %d\n", getpid());
		exit(0);
	}
	pid2 = fork();
	if(pid2 == 0){
		printf("Figlio PID: %d\n", getpid());
		exit(0);
	}
	if(!pid1 && !pid2){
		printf("Padre PID: %d\n", getpid()); // non so in che ordine verranno scritte queste istruzioni
		printf("Figlio 1 PID: %d\n", pid1);
		printf("Figlio 2 PID: %d\n", pid2);
		exit(0);
	}
}

Per sincronizzare i processi posso utilizzare la chiamata wait(). Questa istruzione blocca il programma che l'ha chiamata. Cosa fa?
Qunado un figlio termina, il padre viene sbloccato. 

pid_t wait(int *) //il valore resituito è il n PID del figlio terminato. Si passa come parametro un valore intero (moltiplicato per 256) passato dal figlio al padre

Se inserissi due istruzioni di wait tra le printf, saprei l'ordine esatto in cui i processi terminano

if(!pid1 && !pid2){
		printf("Padre PID: %d\n", getpid());
		printf("Figlio 1 PID: %d\n", pid1);
		printf("Figlio 2 PID: %d\n", pid2);
		//qui vanno le 2 wait(), credo 
		exit(0);
}

Esiste anche la funzione waitpid

pid_t waitpid(pid_t pid, int* status, int options) //opzioni irrilevanti (mettiamo a 0)
Con questo il padre aspetta la terminazione del figlio con PID==pid (il primo parametro passato)

La funzione exec permette di creare un figlio che ha il segmento codice e dati differenti da quello del padre, ma uguali a quelli di un file eseguibile.

int execl(char * path, char * arg0, char * arg1, ...) //path è il percorso dove è situato il programma, arg0, ecc... sono puntatori a stringhe che verranno passate come parametri al main del programma. arg0 è il nome del programma e argN è null per indicare che sono finiti i parametri

Il processo zombie è terminato ma non è ancora stato pulito perché aspetta il ritorno dei figli.

Supponiamo che il padre abbia PID=500 e il figlio 1 ha PID 501. Il padre finisce dopo figlio 1 che finisce dopo figlio 2
int main(){
	int i,j,k,stato;
	pid_t pid1, pid2;
	i=10; j=20; k=30;
	pid1 = fork();
	if(pid1==0){
		j++;
		pid2 = fork();
		if(pid2==0){
			k++;
			exit();
		}else{
			wait(&stato);
			exit();
		}
	}else{
		i++;
		wait(&stato);
		exit();
	}
}


I THREAD
Modello dei thread. È nato dopo il multiprocesso.
All'interno di un processo possono essere attivi più thread contemporaneamente (non in esecuzione)
Esistono processi "normali", cioè a singolo thread, oppure multithread che conividono dati e file (parte dei dati e codice intero condivisi) ma una pila diversa. Quindi le variabili locali sono proprie di ogni thread. Ogni thread ha associato uno stato di esecuzione.
Per semplificare definiamo 3 stati del thread:
	1)esecuzione: sta eseguendo operazioni sul processore
	2)pronto: p. per essere eseguito ma il processore è occupato
	3)attesa: quando devo interagire con periferiche (disco fisso, tastiera, mouse, video, ...)

Utilizziamo lo standard POSIX Pthread
Il thread è gestito direttamente dal kernel del SO. Quando il thread va in esecuzione gli viene assegnato un quanto di tempo durante il quale può utilizzare il processore. Se finisce prima bene, altrimenti viene interrotto e accodato

Concorrenza vs parallelismo
Due attività A e B sono sequenziali se è possibile stabilire un ordine di esecuzione A<B o B<A.
A e B si dicono concorrenti se non si possono dire sequenziali
A e B si dicono parallele se non è possibile stabilire un ordine di esecuzione tra le attività di A e quelle di B
Nell'ipotesi di avere un solo processore concorrenza e parallelismo sono la stessa cosa

Se termina il main, terminano i thread, in qualunque stato fossero.
Ogni thread ha il suo threadID, univoco all'interno del processo ma non al suo esterno
Attesa: metodo join. Non ci sono thread padri o figli, c'è la possibilità di aspettare il thread desiderato sapendone il threadID
Terminazione: return. Esiste anche la exit come per i processi
Ogni processo ha il suo thread principale, che è la funzione main, creata automaticamente.
Ogni thread ha la sua pila ma le variabili globali sono in comune

Sintassi funzioni per i thread:
pthread_create(pthread_t * threadID, pthread_t *attr, void * (*start_func)(void *), void * arg)
	Argomenti: threadID, null, start_func, puntatore ad area di memoria che voglio passare al thread
int pthread_join(phtread_t target_thread, void * status)
	Argomenti: chi sto aspettando, var in cui viene scritto valore return

Esempio:

#include <pthread.h>
#include <stdio.h>
void * tfi(void * tID){
	int conta = 0;
	conta++;
	printf("sono il thread n.%d, conta=%d\n", (int)tID, conta);
	return NULL;
}

int main(){
	pthread_t tID1, tID2;
	pthread_create(&tID1, NULL, &tf1, (void *)1);
	pthread_create(&tID2, NULL, &tf2, (void *)2);
	pthread_join(tID1, NULL);
	pthread_join(tID2, NULL);
	return 0;
}

Così l'ordine di esecuzione non si sa. Adesso apporto una modifica:
int conta = 0 diventa static int conta = 0.
Così facendo non ho la certezza dell'ordine di esecuzione dei due thread, ma so che il risultato è ordinato.
Se non avessi messo la join è possibile che la variabile conta non venisse incrementata da nessuno
